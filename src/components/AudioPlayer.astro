---
interface Props {
  url: string;
}

const { url } = Astro.props;
const filename = decodeURIComponent(url.split("/").pop() || "");

// Extract waveform peaks at build time (avoids CORS issues in the browser)
function extractPeaksFromWav(buffer: ArrayBuffer, numBars = 200): number[] {
  const view = new DataView(buffer);
  if (buffer.byteLength < 44) return [];

  // Walk WAV chunks to find "fmt " and "data"
  let offset = 12;
  let channels = 1;
  let bitsPerSample = 16;
  let dataOffset = 0;
  let dataSize = 0;

  while (offset < view.byteLength - 8) {
    const id = String.fromCharCode(
      view.getUint8(offset), view.getUint8(offset + 1),
      view.getUint8(offset + 2), view.getUint8(offset + 3),
    );
    const size = view.getUint32(offset + 4, true);

    if (id === "fmt ") {
      channels = view.getUint16(offset + 10, true);
      bitsPerSample = view.getUint16(offset + 22, true);
    } else if (id === "data") {
      dataOffset = offset + 8;
      dataSize = size;
      break;
    }

    offset += 8 + size;
    if (size % 2 !== 0) offset++; // WAV chunks are word-aligned
  }

  if (!dataOffset) return [];

  const bytesPerSample = bitsPerSample / 8;
  const bytesPerFrame = bytesPerSample * channels;
  const totalFrames = Math.floor(dataSize / bytesPerFrame);
  const blockSize = Math.floor(totalFrames / numBars);
  if (blockSize === 0) return [];

  const peaks: number[] = [];
  for (let i = 0; i < numBars; i++) {
    let max = 0;
    for (let j = 0; j < blockSize; j++) {
      const bytePos = dataOffset + (i * blockSize + j) * bytesPerFrame;
      if (bytePos + bytesPerSample > buffer.byteLength) break;

      let value: number;
      if (bitsPerSample === 16) {
        value = Math.abs(view.getInt16(bytePos, true)) / 32768;
      } else if (bitsPerSample === 24) {
        const b0 = view.getUint8(bytePos);
        const b1 = view.getUint8(bytePos + 1);
        const b2 = view.getInt8(bytePos + 2);
        value = Math.abs((b2 << 16) | (b1 << 8) | b0) / 8388608;
      } else if (bitsPerSample === 32) {
        value = Math.abs(view.getFloat32(bytePos, true));
      } else {
        value = Math.abs(view.getUint8(bytePos) - 128) / 128;
      }

      if (value > max) max = value;
    }
    peaks.push(max);
  }

  const peakMax = Math.max(...peaks, 0.01);
  return peaks.map((p) => Math.round((p / peakMax) * 100) / 100);
}

let peaks: number[] = [];
let duration = 0;
try {
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  peaks = extractPeaksFromWav(buffer, 200);

  // Calculate duration from WAV header
  const view = new DataView(buffer);
  if (buffer.byteLength >= 32) {
    let off = 12;
    while (off < view.byteLength - 8) {
      const id = String.fromCharCode(
        view.getUint8(off), view.getUint8(off + 1),
        view.getUint8(off + 2), view.getUint8(off + 3),
      );
      const size = view.getUint32(off + 4, true);
      if (id === "fmt ") {
        const byteRate = view.getUint32(off + 16, true);
        // Find data chunk size for duration calc
        let dOff = off + 8 + size;
        if (size % 2 !== 0) dOff++;
        while (dOff < view.byteLength - 8) {
          const dId = String.fromCharCode(
            view.getUint8(dOff), view.getUint8(dOff + 1),
            view.getUint8(dOff + 2), view.getUint8(dOff + 3),
          );
          const dSize = view.getUint32(dOff + 4, true);
          if (dId === "data") {
            duration = byteRate > 0 ? dSize / byteRate : 0;
            break;
          }
          dOff += 8 + dSize;
          if (dSize % 2 !== 0) dOff++;
        }
        break;
      }
      off += 8 + size;
      if (size % 2 !== 0) off++;
    }
  }
} catch (err) {
  console.error(`Failed to extract waveform for ${url}:`, err);
}

function formatTime(seconds: number): string {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${s.toString().padStart(2, "0")}`;
}

const peaksJson = JSON.stringify(peaks);
const durationStr = duration > 0 ? formatTime(duration) : "0:00";
---

<div class="waveform-player" data-url={url} data-peaks={peaksJson} data-duration={duration}>
  <button class="play-btn" aria-label="Play">
    <svg class="icon-play" viewBox="0 0 24 24" fill="currentColor">
      <path d="M8 5v14l11-7z" />
    </svg>
    <svg class="icon-pause" viewBox="0 0 24 24" fill="currentColor" style="display:none">
      <rect x="6" y="5" width="4" height="14" />
      <rect x="14" y="5" width="4" height="14" />
    </svg>
  </button>
  <div class="waveform-right">
    <p class="audio-filename">{filename}</p>
    <canvas class="waveform-canvas"></canvas>
    <span class="time-display">0:00 / {durationStr}</span>
  </div>
</div>

<style>
  .waveform-player {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background: #f8f8f8;
    border-radius: 8px;
    padding: 0.75rem 1rem;
    margin: 0.5rem 0;
  }

  .play-btn {
    flex-shrink: 0;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: #222;
    color: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s;
  }

  .play-btn:hover {
    background: #444;
  }

  .play-btn svg {
    width: 20px;
    height: 20px;
  }

  .waveform-right {
    flex: 1;
    min-width: 0;
  }

  .audio-filename {
    font-size: 0.75rem;
    color: #888;
    margin: 0 0 0.3rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .waveform-canvas {
    display: block;
    width: 100%;
    height: 48px;
    cursor: pointer;
    border-radius: 4px;
  }

  .time-display {
    font-size: 0.7rem;
    color: #888;
    margin-top: 0.2rem;
    display: block;
    font-variant-numeric: tabular-nums;
  }
</style>

<script>
  class WaveformPlayer {
    private container: HTMLElement;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private audio: HTMLAudioElement;
    private playBtn: HTMLButtonElement;
    private iconPlay: SVGElement;
    private iconPause: SVGElement;
    private timeDisplay: HTMLElement;
    private peaks: number[];
    private animId: number | null = null;
    private isDragging = false;

    private readonly ACCENT = "#f97316";
    private readonly UNPLAYED = "#c4c4c4";
    private readonly BAR_GAP = 2;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector(".waveform-canvas")!;
      this.ctx = this.canvas.getContext("2d")!;
      this.playBtn = container.querySelector(".play-btn")!;
      this.iconPlay = container.querySelector(".icon-play")!;
      this.iconPause = container.querySelector(".icon-pause")!;
      this.timeDisplay = container.querySelector(".time-display")!;

      // Read pre-computed peaks from build-time data attribute
      try {
        this.peaks = JSON.parse(container.dataset.peaks || "[]");
      } catch {
        this.peaks = [];
      }

      this.audio = new Audio();
      this.audio.preload = "metadata";
      this.audio.src = container.dataset.url!;

      this.audio.addEventListener("loadedmetadata", () => {
        this.updateTime();
      });

      this.bindEvents();
      this.sizeCanvas();
      this.drawWaveform();
    }

    private bindEvents() {
      this.playBtn.addEventListener("click", () => this.togglePlay());

      this.audio.addEventListener("ended", () => {
        this.setPlaying(false);
        this.drawWaveform();
      });

      // Canvas seek (mouse)
      this.canvas.addEventListener("mousedown", (e) => {
        this.isDragging = true;
        this.seek(e);
      });
      window.addEventListener("mousemove", (e) => {
        if (this.isDragging) this.seek(e);
      });
      window.addEventListener("mouseup", () => {
        this.isDragging = false;
      });

      // Canvas seek (touch)
      this.canvas.addEventListener("touchstart", (e) => {
        this.isDragging = true;
        this.seekTouch(e);
      }, { passive: false });
      this.canvas.addEventListener("touchmove", (e) => {
        if (this.isDragging) {
          e.preventDefault();
          this.seekTouch(e);
        }
      }, { passive: false });
      this.canvas.addEventListener("touchend", () => {
        this.isDragging = false;
      });

      // Responsive resize
      const ro = new ResizeObserver(() => {
        this.sizeCanvas();
        this.drawWaveform();
      });
      ro.observe(this.canvas);
    }

    private sizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    private drawWaveform() {
      const w = this.canvas.clientWidth;
      const h = this.canvas.clientHeight;
      this.ctx.clearRect(0, 0, w, h);

      if (!this.peaks.length) return;

      const numBars = this.peaks.length;
      const barWidth = (w - (numBars - 1) * this.BAR_GAP) / numBars;
      const progress = this.audio.duration
        ? this.audio.currentTime / this.audio.duration
        : 0;
      const progressX = progress * w;
      const minBarH = 2;

      for (let i = 0; i < numBars; i++) {
        const x = i * (barWidth + this.BAR_GAP);
        const barH = Math.max(minBarH, this.peaks[i] * h * 0.9);
        const y = (h - barH) / 2;

        this.ctx.fillStyle = x + barWidth <= progressX ? this.ACCENT : this.UNPLAYED;
        this.ctx.beginPath();
        this.roundRect(x, y, barWidth, barH, 1);
        this.ctx.fill();
      }
    }

    private roundRect(x: number, y: number, w: number, h: number, r: number) {
      r = Math.min(r, w / 2, h / 2);
      this.ctx.moveTo(x + r, y);
      this.ctx.lineTo(x + w - r, y);
      this.ctx.arcTo(x + w, y, x + w, y + r, r);
      this.ctx.lineTo(x + w, y + h - r);
      this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      this.ctx.lineTo(x + r, y + h);
      this.ctx.arcTo(x, y + h, x, y + h - r, r);
      this.ctx.lineTo(x, y + r);
      this.ctx.arcTo(x, y, x + r, y, r);
      this.ctx.closePath();
    }

    private seek(e: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      if (this.audio.duration) {
        this.audio.currentTime = ratio * this.audio.duration;
        this.updateTime();
        this.drawWaveform();
      }
    }

    private seekTouch(e: TouchEvent) {
      const touch = e.touches[0];
      if (!touch) return;
      const rect = this.canvas.getBoundingClientRect();
      const ratio = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      if (this.audio.duration) {
        this.audio.currentTime = ratio * this.audio.duration;
        this.updateTime();
        this.drawWaveform();
      }
    }

    private togglePlay() {
      if (this.audio.paused) {
        this.audio.play();
        this.setPlaying(true);
        this.startAnimation();
      } else {
        this.audio.pause();
        this.setPlaying(false);
        this.stopAnimation();
      }
    }

    private setPlaying(playing: boolean) {
      this.iconPlay.style.display = playing ? "none" : "";
      this.iconPause.style.display = playing ? "" : "none";
      this.playBtn.setAttribute("aria-label", playing ? "Pause" : "Play");
      if (!playing) this.stopAnimation();
    }

    private startAnimation() {
      const tick = () => {
        this.drawWaveform();
        this.updateTime();
        this.animId = requestAnimationFrame(tick);
      };
      this.animId = requestAnimationFrame(tick);
    }

    private stopAnimation() {
      if (this.animId !== null) {
        cancelAnimationFrame(this.animId);
        this.animId = null;
      }
    }

    private updateTime() {
      const cur = this.audio.currentTime || 0;
      const dur = this.audio.duration || 0;
      this.timeDisplay.textContent = `${this.formatTime(cur)} / ${this.formatTime(dur)}`;
    }

    private formatTime(seconds: number): string {
      if (!isFinite(seconds)) return "0:00";
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    }
  }

  // Initialize all players on the page
  document.querySelectorAll<HTMLElement>(".waveform-player").forEach((el) => {
    new WaveformPlayer(el);
  });
</script>
